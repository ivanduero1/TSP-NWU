1. General function:

READ from name_file:
    CREATE list of city names

READ from distance_file:
    CREATE list of distance

INITIALIZE dictionary names_distance
SET i = 0
FOR name1 in city names:
    FOR name2 in city names:
        ADD dict[key] = list of distance[i]
        INCREMENT 1 to i
    ENDFOR
ENDFOR

RETURN list of names, dict


2. Greedy

CREATE list of names, the dictionary names_distance
SET a dict of candidate route

FOR name in list of names:
    INITIALIZE the route as a list
    SET the distance to 0
    APPEND name to the route
    FOR i in range(len(list of names)):
        IF length of the route is 7:
            GLOBAL candidate route
            APPEND distance:route to candidate route
            APPEND distance to candidate distance
        ELSE:
            SET a list of distance from name
            FOR key in dict names_value.keys():
                IF the route[-1] in key[0]:
                        APPEND dict[key] to list of distance from name 
                ENDIF
            ENDFOR
            CALCULATE the min of list of distance from name 
            APPEND dict[key] which has the min distance to the route
            INCREMENT min distance to distance
        ENDIF
    ENDFOR

CALCULATE the min distance using candidate distance
RETURN min distance and candidate route[distance]

3. Mutation Algorithms

INITIALIZE a parent_route in order of the names text file
INITIALIZE a parent_distance to 0

# INITIALIZE
CREATE a parent_route in order of the name text file and dictionary
# Getting distance:
FOR i in range(len(list of city names)-1):
    INCREMENT dict[list of names[i],list of name[i+1]] to parent_distance 
ENDFOR

# TERMINATE
SET stagnation to 0
INITIALIZE a stagnation_dict to store stagnation and its distance
WHILE stagnation != 5:
    SET best_offspring_route to parent_route
    SET best_offspring_distance to parent_distance

    #MUTATE

    FOR offspring in range(10):
        CHOOSE 2 random sample cities from parent_route
        COPY parent_route
        REMOVE sample 1 from the copy 
        APPEND sample 2 to the copy
        CALL function getting distance to calculate the distance of the candidate 
    ENDFOR
    
    #SELECT

        IF offspring's distance < best_offspring_distance:
            UPDATE best_offspring_route to the copy
            UPDATE best_offspring_distance to candidate_distance
        ENDIF
    
    IF best_offspring_distance == parent_distance:
        INCREMENT 1 to stagnation 
        APPEND stagnation and its distance to stagnation_dict
        SET stagnation to parent_route
        SET stagnation_distance to parent_distance
        FOR i in range(3):
            CHOOSE 2 random sample cities from parent_route
            COPY parent_route called s solution
            REMOVE sample 1 from the copy 
            APPEND sample 2 to the copy
            CALL function getting distance to calculate the distance of the s 
        ENDFOR
        UPDATE parent_route to s 
        UPDATE parent_distance to s_distance
    ELSE:
        UPDATE parent_route to best offspring route
        UPDATE parent_distance to best offspring distance
    ENDIF

    FOR key in stagnation_dict.keys():
        IF dict[key] == found min distance of the stagnation: 
            PRINT the key 

4. Backtracking 







    

